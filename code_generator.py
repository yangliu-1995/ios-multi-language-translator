#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Localization code generator module
Generate Swift and Objective-C code for localized strings
"""

import os
import re
from typing import Dict, Set


class LocalizationCodeGenerator:
    """Localization code generator for Swift and Objective-C"""
    
    def __init__(self):
        self.reserved_keywords = {
            'associatedtype', 'class', 'deinit', 'enum', 'extension', 'fileprivate', 'func',
            'import', 'init', 'inout', 'internal', 'let', 'open', 'operator', 'private',
            'protocol', 'public', 'static', 'struct', 'subscript', 'typealias', 'var',
            'break', 'case', 'continue', 'default', 'defer', 'do', 'else', 'fallthrough',
            'for', 'guard', 'if', 'in', 'repeat', 'return', 'switch', 'where', 'while',
            'as', 'Any', 'catch', 'false', 'is', 'nil', 'rethrows', 'super', 'self',
            'Self', 'throw', 'throws', 'true', 'try', 'description'
        }
    
    def generate_swift_extensions(self, strings_dict: Dict[str, str], output_path: str = None) -> str:
        """
        Generate Swift String and LocalizedStringKey extension code
        
        Args:
            strings_dict: Dictionary of key-value pairs
            output_path: Output file path, will write to file if provided
            
        Returns:
            str: Generated Swift code
        """
        # Generate valid Swift property names
        property_names = self._generate_property_names(strings_dict)
        
        # Generate code
        swift_code = self._generate_swift_code(strings_dict, property_names)
        
        # If output path is provided, write to file
        if output_path:
            try:
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                with open(output_path, 'w', encoding='utf-8') as file:
                    file.write(swift_code)
                print(f"Swift extensions written to: {output_path}")
            except Exception as e:
                print(f"Error writing Swift file {output_path}: {e}")
        
        return swift_code
    
    def generate_objc_header(self, strings_dict: Dict[str, str], output_path: str = None) -> str:
        """
        Generate Objective-C header file for use in Objective-C code
        
        Args:
            strings_dict: Dictionary of string key-value pairs
            output_path: Output file path
            
        Returns:
            str: Generated Objective-C header file content
        """
        header = '''//
//  LocalizedStrings.h
//  Generated by AppleStringsTranslator
//

#import <Foundation/Foundation.h>

NS_ASSUME_NONNULL_BEGIN

@interface LocalizedStrings : NSObject

'''
        
        methods = []
        property_names = self._generate_property_names(strings_dict)
        
        for key, property_name in property_names.items():
            value = strings_dict[key]
            comment = f'/// {value}'
            if len(value) > 50:
                comment = f'/// {value[:47]}...'
            
            method = f'''{comment}
+ (NSString *){property_name};
'''
            methods.append(method)
        
        footer = '''
@end

NS_ASSUME_NONNULL_END
'''
        
        objc_header = header + '\n'.join(methods) + footer
        
        # If output path is provided, write to file
        if output_path:
            try:
                os.makedirs(os.path.dirname(output_path), exist_ok=True)
                with open(output_path, 'w', encoding='utf-8') as file:
                    file.write(objc_header)
                print(f"Objective-C header written to: {output_path}")
            except Exception as e:
                print(f"Error writing Objective-C header {output_path}: {e}")
        
        return objc_header
    
    def _generate_property_names(self, strings_dict: Dict[str, str]) -> Dict[str, str]:
        """
        Generate valid Swift property names for each string key
        
        Args:
            strings_dict: Dictionary of string key-value pairs
            
        Returns:
            Dict[str, str]: Mapping from original key names to Swift property names
        """
        property_names = {}
        used_names = set()
        
        for key in strings_dict.keys():
            # Convert to camelCase
            property_name = self._to_camel_case(key)
            
            # Ensure it's not a reserved keyword
            if property_name in self.reserved_keywords:
                property_name = f"localized{property_name.capitalize()}"
            
            # Ensure name is unique
            original_name = property_name
            counter = 1
            while property_name in used_names:
                property_name = f"{original_name}{counter}"
                counter += 1
            
            property_names[key] = property_name
            used_names.add(property_name)
        
        return property_names
    
    def _to_camel_case(self, text: str) -> str:
        """
        Convert text to camelCase
        
        Args:
            text: Original text
            
        Returns:
            str: Text in camelCase format
        """
        # Remove non-alphanumeric characters, replace with underscores
        text = re.sub(r'[^a-zA-Z0-9_]', '_', text)
        
        # Split words
        words = text.split('_')
        
        # Filter empty strings
        words = [word for word in words if word]
        
        if not words:
            return 'localizedString'
        
        # First word lowercase, rest capitalized
        camel_case = words[0].lower()
        for word in words[1:]:
            if word:
                camel_case += word.capitalize()
        
        # Ensure starts with a letter
        if not camel_case[0].isalpha():
            camel_case = 'localized' + camel_case.capitalize()
        
        return camel_case
    
    def _generate_swift_code(self, strings_dict: Dict[str, str], property_names: Dict[str, str]) -> str:
        """Generate Swift extension code"""
        
        # File header comment
        header = '''//
//  LocalizedStrings.swift
//  Generated by AppleStringsTranslator
//
//  This file contains extensions for String and LocalizedStringKey
//  to provide easy access to localized strings.
//

import Foundation
import SwiftUI

'''
        
        # String extension
        string_extension = self._generate_string_extension(strings_dict, property_names)
        
        # LocalizedStringKey extension
        localized_string_key_extension = self._generate_localized_string_key_extension(strings_dict, property_names)
        
        return header + string_extension + '\n' + localized_string_key_extension
    
    def _generate_string_extension(self, strings_dict: Dict[str, str], property_names: Dict[str, str]) -> str:
        """Generate String extension"""
        
        extension_start = '''// MARK: - String Extension for Localized Strings
extension String {
'''
        
        extension_end = '}\n'
        
        properties = []
        
        # Generate static properties
        for key, property_name in property_names.items():
            value = strings_dict[key]
            comment = f'    /// {value}'
            if len(value) > 50:
                comment = f'    /// {value[:47]}...'
            
            property_code = f'''{comment}
    static var {property_name}: String {{
        return NSLocalizedString("{key}", comment: "")
    }}
'''
            properties.append(property_code)
        
        return extension_start + '\n'.join(properties) + extension_end
    
    def _generate_localized_string_key_extension(self, strings_dict: Dict[str, str], property_names: Dict[str, str]) -> str:
        """Generate LocalizedStringKey extension"""
        
        extension_start = '''// MARK: - LocalizedStringKey Extension for SwiftUI
extension LocalizedStringKey {
'''
        
        extension_end = '}\n'
        
        properties = []
        
        # Generate static properties
        for key, property_name in property_names.items():
            value = strings_dict[key]
            comment = f'    /// {value}'
            if len(value) > 50:
                comment = f'    /// {value[:47]}...'
            
            property_code = f'''{comment}
    static var {property_name}: LocalizedStringKey {{
        return LocalizedStringKey("{key}")
    }}
'''
            properties.append(property_code)
        
        return extension_start + '\n'.join(properties) + extension_end
    
    def generate_usage_example(self, strings_dict: Dict[str, str], property_names: Dict[str, str]) -> str:
        """Generate usage example code"""
        
        if not strings_dict:
            return ""
        
        # Select a few examples
        example_keys = list(strings_dict.keys())[:3]
        
        examples = '''// MARK: - Usage Examples

/*
// UIKit usage:
label.text = .doneButtonDefaultTitle
button.setTitle(.cancelButton, for: .normal)

// SwiftUI usage:
Text(.welcomeMessage)
Button(.doneButtonDefaultTitle) { }

// Available properties:
'''
        
        for key in example_keys:
            property_name = property_names[key]
            value = strings_dict[key]
            examples += f'// String.{property_name} -> "{value}"\n'
            examples += f'// LocalizedStringKey.{property_name}\n'
        
        examples += '*/\n'
        
        return examples


# For backward compatibility, keep the old function name
def generate_objc_header(strings_dict: Dict[str, str], output_path: str = None) -> str:
    """
    Generate Objective-C header file for use in Objective-C code
    (Backward compatibility function)
    
    Args:
        strings_dict: Dictionary of string key-value pairs
        output_path: Output file path
        
    Returns:
        str: Generated Objective-C header file content
    """
    generator = LocalizationCodeGenerator()
    return generator.generate_objc_header(strings_dict, output_path)


# For backward compatibility
SwiftCodeGenerator = LocalizationCodeGenerator
